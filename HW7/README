Intro to NLP, Assignment 7: Finite-State Programming

Team members:
Jinyi Guo
Li-Yi Lin



2. 
  (a)
    ii. First accepts languages that start with "0", have arbritary combinations of "0" and "1" in the middle, and have at least three "1" in the end.
        0 and 1 are quoted in the .grm file because they are seen as a unit in the FST.
      
    iii. There are 5 states and 9 arcs.
    
  (b)
    i. the First language can be simplified as 
       export Second = Optimize[Zero Bit* One One One];
       
    ii. Disagreements should accept nothing.
    
  (c)
    i. The First language has 20 states and 25 arcs.
       The Second language has 13 states and 16 arcs.
       
    ii. Because now the First and Second language are not the same, the Disagreements will branches into two sub-FSA, (First - Second) and (Second - First).
    
    iii. The result output includes duplicate string when the input is accepted. This is because the unoptimized version contains all possible "routes" of a given FSM. For example, input string "00111" can be either interpreted as "Zero Zero One One One" or "Zero Bit One One One", that is why grmtest outputs two duplicate strings.

  (d)
    We got same result as problem 2(b), i.e. a FSA with no arc or state at all and hence acceptes nothing.
    The reason is that when we "subtract" one unoptimized FSA with another (e.g. First - Second), the resulting FSA, though may have many states and arcs, accepts nothing because of some "flaws" like no ending state.

4
    (a) a(b*|c+)a
    
    (b) 0 outputs: a
        1 outputs: aba
        2 outputs: aa
        more than 2 outputs: aca
        
    (c) This relation matches a string with an "a" in both the first place and the last place, with either 0 or more "b"s or 1 or more "c"s or nothing in between. The first and last "a"s will remain unchanged, while each "b" in between will be transduced to a "x" (if there is any), or each "c" will be transduced to 0 or more "y"s if there are "c"s in between, or if there is nothing between the two "a"s, insert "fric" in between.
    
    
    (d) The optimized version of Cross is consistent with the result above. There are 10 states and 16 arcs.
    
5.
    (c) Invalid input.
    
    (d) Valid input but produces no output.
    
    
    (f) Transduce 0 or 1 to all possible binary numbers that can generate them by Parity2.
    
    
6.
  (a)
    i. export NP = Optimize[("Art" | "Quant")? ("Adj")* ("Noun")+];
    Accepted examples: AdjNoun, ArtNoun, ArtAdjAdjNounNoun.
        
    ii. There are 13 states and 17 arcs.
    The machine splits each alphabet into an unique state, with the same alphabet shared by multiple words (e.g. "t" is both in "Quant" and "Art") only appears once and being resued.
    
  (c)
    i. This composition will transform a NP to a MakeNmod form. If the input string is not a NP, then it will fail to rewrite. 
    ii. ArtAdjNounNounNoun -> ArtAdjNmodNmodNoun
        AdjNounNounNounNounVerb -> Rewrite failed.
    iii. MakeNmod has 36 states and 46 arcs. TransformNP, on the other, has 16 states and 20 arcs.
    iv. The topology of TransformNP is very similar to NP. The only difference is that TransformNP has a branch to represent Nmod* and Noun must be the last tag of a string.
    
  (d) 
    BracketNP will use <> to enclose a NP and if the input is not a NP, it will fail. For example:
    ArtAdj -> Rewrite failed.
    AdjNoun -> <AdjNoun>
    VerbArtAdjNounNounNounVerbPrepNoun -> Rewrite failed.
    
    
    Whereas Brackets1 will enclose a substring that is a NP but not necessarily enclose all the NPs. So it might have many output strings. For instance:
    ArtAdj -> ArtAdj
    AdjNoun -> Adj<Noun>
    VerbArtAdjNounNounNounVerbPrepNoun -> 
        Output string: VerbArtAdjNounNoun<Noun>VerbPrep<Noun>
        Output string: VerbArtAdjNoun<NounNoun>VerbPrep<Noun>
        Output string: VerbArt<AdjNoun>Noun<Noun>VerbPrepNoun
        Output string: VerbArt<AdjNoun><Noun>NounVerbPrepNoun
        Output string: VerbArtAdj<NounNounNoun>VerbPrepNoun
        Output string: VerbArtAdjNoun<Noun><Noun>VerbPrepNoun
        Output string: VerbArtAdj<Noun><Noun>NounVerbPrep<Noun>
        Output string: VerbArtAdjNoun<Noun>NounVerbPrepNoun
        Output string: Verb<ArtAdjNoun><Noun><Noun>VerbPrepNoun
        Output string: VerbArtAdj<Noun>Noun<Noun>VerbPrepNoun
        Output string: VerbArtAdj<NounNoun><Noun>VerbPrepNoun
        Output string: VerbArtAdjNounNoun<Noun>VerbPrepNoun
        Output string: Verb<ArtAdjNounNoun><Noun>VerbPrep<Noun>
        Output string: Verb<ArtAdjNoun><NounNoun>VerbPrepNoun
        Output string: VerbArtAdj<NounNoun>NounVerbPrepNoun
        Output string: VerbArtAdj<Noun><NounNoun>VerbPrep<Noun>
        Output string: VerbArt<AdjNoun><Noun>NounVerbPrep<Noun>
        Output string: VerbArt<AdjNounNoun>NounVerbPrepNoun
        Output string: VerbArtAdjNounNounNounVerbPrepNoun
        Output string: VerbArt<AdjNoun>NounNounVerbPrep<Noun>
        Output string: Verb<ArtAdjNoun>NounNounVerbPrep<Noun>
        Output string: VerbArtAdj<Noun><Noun><Noun>VerbPrepNoun
        Output string: VerbArtAdj<NounNounNoun>VerbPrep<Noun>
        Output string: VerbArt<AdjNounNounNoun>VerbPrepNoun
        Output string: Verb<ArtAdjNoun><Noun>NounVerbPrep<Noun>
        Output string: Verb<ArtAdjNounNoun>NounVerbPrepNoun
        Output string: VerbArtAdj<NounNoun><Noun>VerbPrep<Noun>
        Output string: VerbArt<AdjNounNoun><Noun>VerbPrep<Noun>
        Output string: VerbArt<AdjNounNoun><Noun>VerbPrepNoun
        Output string: VerbArt<AdjNoun>Noun<Noun>VerbPrep<Noun>
        Output string: VerbArt<AdjNoun><NounNoun>VerbPrep<Noun>
        Output string: VerbArtAdj<Noun><Noun>NounVerbPrepNoun
        Output string: Verb<ArtAdjNoun><NounNoun>VerbPrep<Noun>
        Output string: Verb<ArtAdjNounNoun><Noun>VerbPrepNoun
        Output string: VerbArt<AdjNoun><Noun><Noun>VerbPrepNoun
        Output string: VerbArtAdj<Noun><NounNoun>VerbPrepNoun
        Output string: VerbArtAdjNounNounNounVerbPrep<Noun>
        Output string: Verb<ArtAdjNoun><Noun>NounVerbPrepNoun
        Output string: VerbArt<AdjNoun><NounNoun>VerbPrepNoun
        Output string: Verb<ArtAdjNounNoun>NounVerbPrep<Noun>
        Output string: VerbArtAdj<Noun><Noun><Noun>VerbPrep<Noun>
        Output string: VerbArtAdjNoun<Noun><Noun>VerbPrep<Noun>
        Output string: VerbArt<AdjNoun><Noun><Noun>VerbPrep<Noun>
        Output string: Verb<ArtAdjNounNounNoun>VerbPrep<Noun>
        Output string: VerbArtAdj<Noun>NounNounVerbPrepNoun
        Output string: VerbArtAdj<Noun>Noun<Noun>VerbPrep<Noun>
        Output string: Verb<ArtAdjNoun>Noun<Noun>VerbPrepNoun
        Output string: Verb<ArtAdjNounNounNoun>VerbPrepNoun
        Output string: VerbArt<AdjNounNounNoun>VerbPrep<Noun>
        Output string: VerbArtAdjNoun<NounNoun>VerbPrepNoun
        Output string: Verb<ArtAdjNoun>NounNounVerbPrepNoun
        Output string: VerbArtAdjNoun<Noun>NounVerbPrep<Noun>
        Output string: VerbArt<AdjNoun>NounNounVerbPrepNoun
        Output string: Verb<ArtAdjNoun>Noun<Noun>VerbPrep<Noun>
        Output string: Verb<ArtAdjNoun><Noun><Noun>VerbPrep<Noun>
        Output string: VerbArt<AdjNounNoun>NounVerbPrep<Noun>
        Output string: VerbArtAdj<NounNoun>NounVerbPrep<Noun>
        Output string: VerbArtAdj<Noun>NounNounVerbPrep<Noun>
    
    Brackets2 will enclose all the substrings that are NPs but might have multiple different output strings because one NP could be separated into several shorter NPs. For example
    ArtAdj -> ArtAdj
    AdjNoun -> <AdjNoun>
    VerbArtAdjNounNounNounVerbPrepNoun ->
        Output string: Verb<ArtAdjNounNoun><Noun>VerbPrep<Noun>
        Output string: Verb<ArtAdjNounNounNoun>VerbPrep<Noun>
        Output string: Verb<ArtAdjNoun><Noun><Noun>VerbPrep<Noun>
        Output string: Verb<ArtAdjNoun><NounNoun>VerbPrep<Noun>
    
7.
    (b)
        "ev'apor'ating" has no possible input ("'evap'orating" is produced by puting "evaporating" to Stress).
        "'incomm'unic'ado" has possible inputs "incommunicado".
        
    (d)
        We add two FSTs to handle the "Y" and "y" case: 
            "ClassifyY" to turn "y" that serves as vowel to "^" and vowel "Y" to "*",
            "RestoreY" to replace "^" or "*" in the processed string back to "y" or "Y" respectively.
        To make "Stress" works as usual, we also have to add "^" and "*" to both "Vowel" and "Sigma".
    
8.
    (a) 
        The present and past tenses of "read" have the same spell but different rhyme.
        
    (b) 
        In the two words, the letter a has 3 different phonemic realizations: AE2, AH0, and AE1.
        AH0: our tongue will be near the top of our mouth.
        AE1: our tongue will be near the bottom of our mouth and our mouth will open larger.
        AE2: our tongue will be near the bottom of our mouth and our mouth will open smaller than AE1.
        
    (c)
        The Results defines a language that only accepts words whose number of syllables is multiple of three, and for each 3 syllables the first one is stressed (has a stress level 1 or 2) and the following two are unstressed, words without syllable (which may not exist) may also be accepted.
        
        The Results is composited by Pronounce, StressPattern and (Dacytl*). It will first match the pronounce with the input word by the Pronounce, and then filter the prouounce to make the string only have the stress marker, 0-2. Finally, (Dacytl*) will output the strings that match the pattern, ("1" | "2") "0" "0". 
        
    (g)
        WordEnding @ Invert[WordEnding] will find all the words that have the same rhyming ending with the input word.
        The input and output alphabets are both ASCII characters (in byte mode). 
        
    (h) 
        If we use "cmudict.txt" for the Pronounce, it will show the error message, "Memory allocation failed." 
        This is probably caused by insufficient memory when we try to allocate memory for two "cmudict.txt". When it perform composition on two FSTs, it will try to find matched intermediate symbol to produce all possible compositions. Thus, if the input has large amount of states and arcs, then it will be very likely to have very high demand in memory space usage.
        
    (i)
        Using pipeline for WordEnding and Invert[WordingEnding] is more efficient than the composition of WordEnding @ Invert[WordingEnding] because when we pass a word to WordEnding, it will eliminate many arcs and states that are not relevant to the word. Therefore, when it passes the result to the next FST, Invert[WordingEnding], it only has one WordEnding to be processed through the next FST and that why it is more efficient.
        
        The dictionary has a rhyme for orange, but doesn't have a rhyme for adventureland.
    
    (j) 
    
9.
    (a) (check???)
        i. The minimum-weighted string for the FSA are "011" and "001", and the minimum weight is 1 + 0.2 + 0.5 = 1.7.
        ii. 